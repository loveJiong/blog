---
title: 个税服务中心和通推版助手差异化分析设计
date: 2018/7/14
password: servyou
---

## 1.利用不同的命令区分不同的打包项目

打包个税服务中心的命令
`npm run prod`
打包通推版助手的命令
`npm run prod --assistant`
输入额外的命令参数--assistant，通过下面的代码来区别本次打包项目的productName
```javascript
/**
 *  是否通推版助手
 *  @returns {boolean}
 */

 function getProductName() {
   let result = 'tax';
   if (process.env.npm_config_argv.indexOf('assistant') !== -1) {
    result = 'assistant';
   }
   return result;
 }
 process.env.productName = getProductName(); // 是否通推版助手
```
并且将获取的producName存放在processs.env.productName，在需要做差异化的地方通过producName的值来区分是哪个产品。

## 2.利用webpack的cssLoader以及上文中的productName进行色系的差异化

项目中有2个基础色系的样式文件，项目中的样式的颜色都是依赖于这2个基础样式文件，只要不同的项目引入不同的基础样式文件，就能达到色系的差异化。
`__variables.scss`个税服务中心基础样式文件，主色系为蓝色
`__assistant.scss`通推版助手基础样式文件，主色系为橘色

通过代码
```javascript
  // 判断当前项目需要导入哪个样式文件
  let variables;
  if (process.env.productName === "assistant") {
    variables = "@import '~assets/__assistant';"
  } else {
    variables = "@import '~assets/__variables';"
  }
  // 为每个样式文件都导入上述的基础样式文件
  return {
    css: generateLoaders(),
    postcss: generateLoaders(),
    sass: generateLoaders('sass', { indentedSyntax: true, data: variables }),
    scss: generateLoaders('sass', { data: variables })
  }
```
这样的话 打包出来的个税服务中心和通推版都分别引入的是自己对应的基础样式文件，实现了色系的差异化

## 3.通推版、个税服务中心内容差异化
话不多说先上图
{% asset_img diff3-1.png 差异化 %}
**funcArea**：需要差异化的区域
**diffService**：差异化服务
**diffConfig**：项目差异化配置文件
**assistantService**： 助手服务端，用来获取不同地区的配置数据

思路很简单，差异化的配置来源分别是本地的配置文件以及通过请求获取的不同地区的配置数据，然后在diffService里进行数据处理，统一提供调用接口给funcArea调用，funcArea调用对应的接口以及传入对应的参数获取到对应项目、地区所展示的页面、组件、文字等数据进行展示。

## 4.以下为具体实现，非战斗人员提前撤离

目前可以识别出的差异化可以分为下面几大类：
* html: 如一个区域A是文字B是图片
* text: 文字的差异化
* components：引入组件的差异化
* router：跳转路由的差异化

于是diffService目前提供了以下几个方法：
```javascript
export default {
  init() {
      //初始化数据的一系列操作
  },

  getHtml(moduleCode) {
    return this.diffConfig[moduleCode].html;
  },

  getText(moduleCode) {
    return this.diffConfig[moduleCode].text;
  },

  getRouter(moduleCode) {
    return this.diffConfig[moduleCode].router;
  },

  getComponentsByCode(moduleCode, areaCode) {
    let result = [];
    try {
      if (areaCode) {
        result = this.diffConfig[moduleCode].components[areaCode];
      } else {
        result = this.diffConfig[moduleCode].components;
      }
    } catch (err) {
      result = [];
    }
    return result;
  },
}
```
**备注**：目前html、text和router只有到module的这一层的差异化，module下更细化的还未涉及到，所以未保持和getComponentsByCode方法一致。

使用示例：
**备注**：如果是组件的话得在vue文件中提前引入组件全集，如何根据getComponentsByCode拿到的组件去引入研究ing。
```html
<template>
  <div v-html="html.title"></div>
  <component v-for="item in components" :is="item"></component>
</template>
<script>
import x from './components/x';
import xx from './components/xx';
import xxx from './components/xxx';
export default {
  components: {
    x,
    xx,
    xxx,
  },
  data() {
    components: this.$diff.getComponentsByCode('header'),
    html: this.$diff.getHtml('header'),
  }
}
</script>
```
这样做的好处一方面就是调用差异化服务的地方，只需要调用对应方法拿到对应的内容进行对应的展示，不需要关心数据的来源、不需要做逻辑判断处理。
另一方面是数据来源如果发生变化，因为中间有一层diffService，只需要在diffService的初始化中，将不同的数据做统一的处理，无论数据源怎么变，来源有多少个，调用的地方永远不用变化。
